#include<iostream>
#include<string>
using namespace std;
class Person
{
public :
	int age;
	string name;
};
//可以在模板参数列表处赋默认参数
template<class Nametype=string,class Agetype=int>
class Animal
{
public:
	Nametype m_name;
	Agetype m_age;
	Animal(string name, int age)
	{
		this->m_name = name;
		this->m_age = age;
	}
	void showanimal()
	{
		cout << this->m_name << " " << this->m_age << endl;
	}
};
template<class T>
bool compare(T&x, T&y)
{
	if (x == y)
		return true;
	else
		return false;
}
//对于模板无法实现的，可以用重载将特殊数据实例化
template<>bool compare(Person&p1, Person&p2)
{
	if (p1.age == p2.age&&p1.name == p2.name)
		return true;
	else
		return false;
}
template<typename T>
//函数模板用于相同数据类型，必须确定T的数据类型才能使用
//作用域仅限一个函数
//普通函数可以发生隐式类型转化，模板中显示指定类型可以，自动类型推导不行
void Swap(T&a, T&b)
{
	T temp = a;
	a = b;
	b = temp;
}
template<typename T>
//用指针无法转换
T Add_1(T x,T y)
{
	return x + y;
}
int Add_2(int a, int b)
{
	return a + b;
}
void test()
{
	int a = 21;
	int b = 76;
	char c = 'c';
	//自动类型推导
	//Swap(a, b);
	//显示指定类型
	Swap<int>(a, b);
	cout << a << " " << b << endl;
	cout << Add_2(a, c) << endl;
	cout<<Add_1<int>(a, c)<<endl;
}
template<class T>
void Sort(T&arr, int len)
{
	for (int i = 0; i < len; i++)
	{
		int maxormin = i;
		for (int j = i + 1; j < len; j++)
		{
			if (arr[maxormin] > arr[j])
				maxormin = j;
		}
		if (i != maxormin)
		{
			Swap(arr[i], arr[maxormin]);
		}
	}
}
template<class T>
void print(T&arr, int len)
{
	for (int i = 0; i < len; i++)
	{
		cout << arr[i] << " ";
	}
	cout << endl;
}
void test_1()
{
	int a[10] = { 3,43,433,332,233,2334,4,22,2,575 };
	char b[10] = "mhixweudw";
	Sort(a, 10);
	Sort(b, 10);
	print(a, 10);
	print(b, 10);
}
void test_2()
{
	int a = 10;
	int b = 10;
	int c = 45;
	Person p1 = { 21,"张三" };
	Person p2 = { 23,"李四" };
	Person p3 = { 21,"张三" };
	compare(a, b);
	compare(a, c);
	compare(p1, p2);
	compare(p1, p3);
}
void test_3()
{
	//即使设置了默认参数，使用类模板时仍要带上空模板
	Animal<>a("拉布拉多", 21);
	a.showanimal();
}
int main()
{
	test();
	test_1();
	test_2();
	test_3();
	return 0;
}

#include"类模板.hpp"
#include"Array.hpp"
using namespace std;
class A
{
public:
	void print1()
	{
		cout << "AAA" << endl;
	}
};
class B
{
public:
	void print2()
	{
		cout << "BBB" << endl;
	}
};
template<class T>
class C
{
public:
	T a;
	void fun1()
	{
		a.print1();
	}
	void fun2()
	{
		a.print2();
	}
	void showtype();
};
//类模板成员函数类外实现要带参数模板
template<class T>
void C<T>::showtype()
{
	cout << typeid(T).name() << endl;
}
template<class T1,class T2>
class D
{
public:
	T1 name;
	T2 num;
	void showinf();
};
template<class T1, class T2>
void D<T1, T2>::showinf()
{
	cout < this->name << " " << this->num << endl;
}
template<class T>
class d
{
public:
	T n;
};
//类的模板继承，一个确定父类成员类型，一个确定子类成员类型
template<class T1,class T2>
class smallD :public d<T1>
{
public:
	T2 m;
	void showtype()
	{
		cout << typeid(T2).name() << endl;
	}
};
//指定传入类型
void print_1(D<string, int>&d)
{
	cout << d.name << " " << d.num << endl;
}
//参数模板化
template<class T1, class T2>
void print_2(D<T1,T2>&p)
{
	cout << p.name << " " << p.num << endl;
	cout << "T1的类型：" << typeid(T1).name() << endl;
	cout << "T2的类型：" << typeid(T2).name() << endl;
}
//整个类的模板化
template<class T>
void print_3(T&p)
{
	cout << "T的类型：" << typeid(T).name() << endl;
}
void test()
{
	smallD<char,string> s;
	s.showtype();
	C<A>c1;
	C<B>c2;
	c1.fun1();
	c1.showtype();
	//c1.fun2();
	//c2.fun1();
	c2.fun2();
	c2.showtype();
	D<string, int>d = { "张三",23 };
	print_1(d);
	print_2(d);
	print_3(d);
}
template<class T>
void printArray(Array<T>&a)
{
	for (int i = 0; i < a.Getsize(); i++)
	{
		cout <<a[i] << " ";
	}
	cout << endl;
}
void test1()
{
	Class<string, string>c("张三","李四");
	c.displayname();
	F<int, int> f(12, 56);
	shownum(f);
	Array<char>a(129);
	Array<char>a1(1000);
	Array<char>a2(1000);
	for (int i = 0; i < 129; i++)
	{
		a.Addelm(i);
	}
	a2 = a1 = a;
	printArray(a2);
	printArray(a);
}
int main()
{
	test();
	test1();
	return 0;
}
